# Singleton 单例模式（懒汉式）

## 1. 核心注意事项
- `instance` 必须使用 `volatile`：防止指令重排导致其他线程读到“半初始化”对象，保证可见性和有序性。
  - `instance = new Singleton()` 实际会经历三步：
    1. 分配内存空间；
    2. 初始化对象（调用构造方法）；
    3. 将 `instance` 引用指向这块内存。
  - 若未使用 `volatile`，步骤 2 与步骤 3 可能发生重排序：线程 A 先执行第 3 步（`instance` 非 `null`），但对象尚未初始化；线程 B 检查 `instance != null` 后直接返回，读取到的是“半初始化”的实例。

- 构造方法声明为 `private`：外部无法通过 `new Singleton()` 构造，单例创建权完全由类自身掌控。

## 2. 双重检查锁定（Double-Checked Locking）
双重检查锁定由两层 `if (instance == null)` 组成，一层“快”、一层“稳”，缺一不可。

### 第一层 if（同步块外）
- 作用：单例已创建后，让调用线程直接返回实例，避免进入 `synchronized` 产生无谓的锁竞争。
- 若缺失：即便单例已存在，所有线程仍需抢锁，性能大幅下降。

### 第二层 if（同步块内）
- 作用：多线程同时通过第一层判断后，进入同步块时再次确认 `instance` 是否仍为 `null`，确保只初始化一次。
- 若缺失：仍可能出现多个线程排队进入同步块并重复执行 `new Singleton()`，破坏单例唯一性。

### 并发场景示意
三个线程同时调用 `getInstance()`：
1. A、B、C 通过第一层判断（此时 `instance` 为 `null`），竞争 `Singleton.class` 锁。
2. A 抢到锁，执行第二层判断并创建实例，释放锁。
3. B、C 依次进入同步块，再次判断发现 `instance != null`，直接返回。
4. 后续调用都在第一层就命中 `instance != null`，整个方法退化为普通读操作。

结论：第一层 `if` 负责“无锁快速返回”，第二层 `if` 负责“同步内核查安全”。两者协同才能实现真正“既安全又高效”的懒汉式单例