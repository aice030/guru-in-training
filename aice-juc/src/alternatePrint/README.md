# TwoNum: 两线程交替打印奇数和偶数

## 1. synchronized锁住的对象

在TwoNum类中创建一个lock对象，synchronized(lock)锁住的是TwoNum的某一个实例，如果有多个TwoNum实例，他们之间锁互不影响
如果是synchronized(TwoNum.class)，则锁住的是整个TwoNum类，所有实例都需要竞争同一把锁

## 2. start()和run()的区别

简单来说：start()是 “启动线程的开关”，负责创建新线程；run()是 “线程的任务内容”，本身不涉及线程的创建。要实现多线程，必须调用start()而非直接调用run()。

### start() 方法：启动新线程，触发多线程执行
  作用：启动一个新的线程（进入 “就绪状态”），由 JVM 自动调用该线程的run()方法，实现真正的多线程并发。
  原理：调用start()后，JVM 会为线程分配独立的栈空间、程序计数器等资源，使其与主线程（或其他线程）并行执行。此时run()方法的执行是在新线程中进行的。
  限制：一个线程对象只能调用一次start()方法，重复调用会抛出IllegalThreadStateException（线程状态异常），因为线程的生命周期中 “启动” 只能进行一次。

### run() 方法：线程的执行体，仅普通方法调用
  作用：定义线程要执行的任务逻辑（线程的 “执行体”），但不会启动新线程，本质是一个普通的成员方法。
  原理：直接调用run()时，方法会在当前线程（调用者所在的线程）中执行，不会创建新线程，相当于同步调用一个普通方法，无法实现多线程并发。
  特点：可以重复调用（只要对象存在），因为它只是普通方法，不涉及线程状态的改变


# ThreeNum: 三线程交替打印1、2、3
## 1. printThreeNum()方法
### 功能
使用notifyAll()方法唤醒所有线程，通过while(flag != k)保证只有符合条件的线程被唤醒时才会打印，实现并发控制。
### 问题
1. 打印结束后程序仍在运行 
原因：当count数达到n退出循环后，其他两个线程没有被正确唤醒，或是仍在while(flag != 2)的循环中等待
解决：检验打印完成应该终止程序后，终止循环前通过notifyAll()唤醒其他可能正在等待的线程
2. 打印数量和预期不符
原因：当while(count<=n)判断错误结束后，可能有线程已经通过了这层判断，正在while（flag != 2)的循环中等待，导致flag和count不一致
解决：将while(count <= n)判断条件改为while(true)，改为在循环中判断打印是否完成，并在线程被唤醒时也添加检查打印是否完成的判断逻辑，确保count和flag的强一致性
